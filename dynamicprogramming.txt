https://skmouse.tistory.com/entry/DP%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DDynamic-Programming-%EC%8B%AC%ED%99%94

1. 최적 부분구조
-> 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다
2. 중복되는 부분 문제
-> 동일한 작은 문제를 반복적으로 해결해야 한다

메모이제이션 
-> dp의 구현기법 중 하나. 한번 계산한 결과를 메모리 공간에 메모하는 방법


top-down
-> 구현과정에서 재귀함수를 이용, 작은문제들을 재귀적으로 호출하여 모두 호출되었을 때 큰 값의 결과가 나옴

bottom-up
-> 아래서 부터 해결, 결과값을 저장하여 아래에서 위로 해결하는 과정
-> dp의 전형적인 형태 (결과 저장용 리스트(배열 = dp테이블))

문제 해결 방법
1. 그리디, 구현, 완전탐색 등의 아이디어로 문제를 해결할 수 있는지를 먼저 검토
2. 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성 후 메모이제이션으로 개선하는 방법


- 최장 증가 부분 수열 (LIS) 알고리즘

[원소개 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 
각 원소가 이전 원소보다 크다는 조건을 만족하고, 
그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 한다]

dp 사용시 O(N^2)
이분탐색 사용시 O(NlogN)
